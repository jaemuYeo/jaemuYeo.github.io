---
title: "CS50 5주차 - 메모리"

categories:
  - cs50

tags:
  - [cs]

toc: true

toc_sticky: true

date: 2021-02-08

last_modified_at: 2021-02-08
---

이 포스팅은 부스트코스의 [CS50 2019 강의](https://www.boostcourse.org/cs112/joinLectures/43415)의 내용을 공부한 글 입니다.

# 메모리

## 메모리 주소

### 16진수(Hexadecimal)

앞서 배웠던 10진수, 2진수 외에 16진수가 있다.

컴퓨터에서 데이터를 처리하기 위해서 16진수를 사용할 때 장점이 있다.

16진수는 10진수보다 2진수를 더 간단하게 나타낼 수 있다.

인간이 사용하는 10진수는 컴퓨터는 이해할 수 없다. 0과 1만을 이해할 수 있기에 16진수를 사용하여 표현한다.

|        |     |     |     |     |     |     |     |     |     |     |     |     |     |     |     |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 10진수 | 0   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   |
| 16진수 | 0   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | A   | B   | C   | D   | E   | F   |

> F = 15

|     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 2^7 | 2^6 | 2^5 | 2^4 | 2^3 | 2^2 | 2^1 | 2^0 |
| 128 | 64  | 32  | 16  | 8   | 4   | 2   | 1   |
| 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   |

위에 표를 10진수로 표현하면 0이되고

|     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 2^7 | 2^6 | 2^5 | 2^4 | 2^3 | 2^2 | 2^1 | 2^0 |
| 128 | 64  | 32  | 16  | 8   | 4   | 2   | 1   |
| 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |

8비트로 표현할 수 있는 최대 값은 1부터 세는게 아니라 0부터 세기때문에 256인 255가 된다.

10진수에서의 255표기법은 이러하다.

|      |      |      |
| ---- | ---- | ---- |
| 10^2 | 10^1 | 10^0 |
| 2    | 5    | 5    |

하지만 16진수에서 255를 표기하면 FF가 나온다. 16은 hex라고도 표현한다.

16진수를 사용하여 연산을 할 때 이렇게 표현하면 매우 편리하다고 한다.

|      |      |
| ---- | ---- |
| 16^1 | 16^0 |
| F    | F    |

---

FF 또는 00 은 RGB를 나타내는 값에서 많이 볼 수 있다.

컴퓨터는 빨간색, 초록색, 파란색으로 색을 표현하는데 각 픽셀의 일정량의 RGB로 나타낸다.

이것을 사람이 표현하기 쉽게 16진법으로 각 색의 양을 나타내도록 정한 것이다.

- R = 00, G = 00, B = 00 -> 000000 (검은색)
- R = FF, G = FF, B = FF -> FFFFFF (흰색)
- R = FF, G = 00, B = 00 -> FF0000 (빨간색)

사람들은 10진수와 16진수의 모호함을 없애기 위해서 16진수를 사용할 때에 모든 수 앞에 0x를 붙이기로 약속했다.

수학적으로 아무런 뜻은 없지만 0x가 붙어있다면 16진수라고 알고있으면 된다.

**16진수의 유용성**

|        | A        | B        | C        |
| ------ | -------- | -------- | -------- |
| 10진수 | 65       | 66       | 67       |
| 2진수  | 01000001 | 01000010 | 01000011 |
| 16진수 | 0x41     | 0x42     | 0x43     |

---

### 메모리 주소

C에서는 변수의 메모리상 주소를 받기 위해 '&'이라는 연산자를 사용한다.

'%p'는 포인터의 약자이다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}

// 0x7ffd4e19f7ec와 같은 16진법으로 표현된 메모리의 주소를 얻는다.
```

반대로 \*를 사용하여 그 메모리에 주소에 있는 실제 값을 얻을 수 있다.

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%i\n", *&n);
}
// 주소를 얻은 뒤 다시 주소에 해당하는 값을 얻어와 출력한다.
// 50
```

---

## 포인터

```c
#include <stdio.h>

int main(void)
{
    int n = 50;
    int *p = &n;
    printf("%p\n", p);
}

// n의 메모리 주소 값
```

변수의 이름을 포인터라는 의미로 p라고 했다.

그 앞에 '\*'연산자가 붙는데 이 연산자는 어떤 메모리 주소에 있는 값을 받아오게 해준다.

위 코드를 보면 변수 n에 50이라는 값을 저장해주고,

\*p라는 포인터 변수에 n의 주소를 저장했다.

int *p의 *는 변수가 포인터라는 의미를 가지고, int는 이 포인터가 int타입의 변수를 의미한다.

<img width="594" alt="무제" src="https://user-images.githubusercontent.com/70311145/107486116-fbacc580-6bc7-11eb-8d0d-504eaffdff61.png">

실제 컴퓨터 메모리에서 변수 p는 이처럼 저장될 수 있다.

하지만 p의 값 (n읭 주소값)을 생각하지 않고, 단지 p가 n을 가리키고 있다는 것만 생각하면 된다.

<img width="598" alt="무제" src="https://user-images.githubusercontent.com/70311145/107486306-39a9e980-6bc8-11eb-8fee-088f22c2a02a.png">

메모리에서 다른 곳을 가리키고 가리키고,,, 가리키고 하다보면 아주 정교한 자료형을 만들 수 있다.

> 생각해보기 - 포인터의 크기는 메모리의 크기와 어떤 관계가 있을까요?

메모리가 커지면 포인터도 커지는 비례관계.

---

## 문자열
